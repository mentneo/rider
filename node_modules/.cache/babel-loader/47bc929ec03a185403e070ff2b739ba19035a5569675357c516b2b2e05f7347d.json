{"ast":null,"code":"import { collection, addDoc, query, where, orderBy, onSnapshot, getDocs, updateDoc, doc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { toast } from 'react-toastify';\n\n/**\n * Send an in-app notification to a specific user\n * @param {string} userId - User ID to receive the notification\n * @param {object} notification - Notification data (title, body, etc.)\n * @returns {Promise<string|null>} - ID of the created notification or null if failed\n */\nexport const sendNotification = async (userId, notification) => {\n  try {\n    const notificationData = {\n      ...notification,\n      createdAt: new Date().toISOString(),\n      read: false\n    };\n    const docRef = await addDoc(collection(db, 'users', userId, 'notifications'), notificationData);\n    return docRef.id;\n  } catch (error) {\n    console.error('Error sending notification:', error);\n    return null;\n  }\n};\n\n/**\n * Listen for notifications for the current user\n * @param {string} userId - User ID to listen for notifications \n * @param {function} onNewNotification - Callback when new notifications arrive\n * @returns {function} - Unsubscribe function\n */\nexport const listenForNotifications = (userId, onNewNotification) => {\n  if (!userId) return () => {};\n  const q = query(collection(db, 'users', userId, 'notifications'), orderBy('createdAt', 'desc'));\n  return onSnapshot(q, snapshot => {\n    const notifications = [];\n    let unreadCount = 0;\n    snapshot.forEach(doc => {\n      const data = doc.data();\n      notifications.push({\n        id: doc.id,\n        ...data\n      });\n      if (!data.read) {\n        unreadCount++;\n      }\n    });\n    onNewNotification(notifications, unreadCount);\n  }, error => {\n    console.error('Error listening for notifications:', error);\n  });\n};\n\n/**\n * Mark a notification as read\n * @param {string} userId - User ID\n * @param {string} notificationId - Notification ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAsRead = async (userId, notificationId) => {\n  try {\n    await updateDoc(doc(db, 'users', userId, 'notifications', notificationId), {\n      read: true,\n      readAt: new Date().toISOString()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error marking notification as read:', error);\n    return false;\n  }\n};\n\n/**\n * Mark all notifications as read\n * @param {string} userId - User ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAllAsRead = async userId => {\n  try {\n    const q = query(collection(db, 'users', userId, 'notifications'), where('read', '==', false));\n    const snapshot = await getDocs(q);\n    const promises = snapshot.docs.map(doc => updateDoc(doc.ref, {\n      read: true,\n      readAt: new Date().toISOString()\n    }));\n    await Promise.all(promises);\n    return true;\n  } catch (error) {\n    console.error('Error marking all notifications as read:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["collection","addDoc","query","where","orderBy","onSnapshot","getDocs","updateDoc","doc","db","toast","sendNotification","userId","notification","notificationData","createdAt","Date","toISOString","read","docRef","id","error","console","listenForNotifications","onNewNotification","q","snapshot","notifications","unreadCount","forEach","data","push","markAsRead","notificationId","readAt","markAllAsRead","promises","docs","map","ref","Promise","all"],"sources":["/Users/yeduruabhiram/Desktop/chiru babai/src/utils/notifications.js"],"sourcesContent":["import { collection, addDoc, query, where, orderBy, onSnapshot, getDocs, updateDoc, doc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { toast } from 'react-toastify';\n\n/**\n * Send an in-app notification to a specific user\n * @param {string} userId - User ID to receive the notification\n * @param {object} notification - Notification data (title, body, etc.)\n * @returns {Promise<string|null>} - ID of the created notification or null if failed\n */\nexport const sendNotification = async (userId, notification) => {\n  try {\n    const notificationData = {\n      ...notification,\n      createdAt: new Date().toISOString(),\n      read: false\n    };\n    \n    const docRef = await addDoc(collection(db, 'users', userId, 'notifications'), notificationData);\n    return docRef.id;\n  } catch (error) {\n    console.error('Error sending notification:', error);\n    return null;\n  }\n};\n\n/**\n * Listen for notifications for the current user\n * @param {string} userId - User ID to listen for notifications \n * @param {function} onNewNotification - Callback when new notifications arrive\n * @returns {function} - Unsubscribe function\n */\nexport const listenForNotifications = (userId, onNewNotification) => {\n  if (!userId) return () => {};\n  \n  const q = query(\n    collection(db, 'users', userId, 'notifications'),\n    orderBy('createdAt', 'desc')\n  );\n  \n  return onSnapshot(q, (snapshot) => {\n    const notifications = [];\n    let unreadCount = 0;\n    \n    snapshot.forEach(doc => {\n      const data = doc.data();\n      notifications.push({\n        id: doc.id,\n        ...data\n      });\n      \n      if (!data.read) {\n        unreadCount++;\n      }\n    });\n    \n    onNewNotification(notifications, unreadCount);\n  }, error => {\n    console.error('Error listening for notifications:', error);\n  });\n};\n\n/**\n * Mark a notification as read\n * @param {string} userId - User ID\n * @param {string} notificationId - Notification ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAsRead = async (userId, notificationId) => {\n  try {\n    await updateDoc(doc(db, 'users', userId, 'notifications', notificationId), {\n      read: true,\n      readAt: new Date().toISOString()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error marking notification as read:', error);\n    return false;\n  }\n};\n\n/**\n * Mark all notifications as read\n * @param {string} userId - User ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAllAsRead = async (userId) => {\n  try {\n    const q = query(\n      collection(db, 'users', userId, 'notifications'),\n      where('read', '==', false)\n    );\n    \n    const snapshot = await getDocs(q);\n    \n    const promises = snapshot.docs.map(doc => \n      updateDoc(doc.ref, {\n        read: true,\n        readAt: new Date().toISOString()\n      })\n    );\n    \n    await Promise.all(promises);\n    return true;\n  } catch (error) {\n    console.error('Error marking all notifications as read:', error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}