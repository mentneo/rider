{"ast":null,"code":"import { collection, addDoc, query, where, orderBy, onSnapshot, getDocs, updateDoc, doc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { toast } from 'react-toastify';\n\n/**\n * Send an in-app notification to a specific user\n * @param {string} userId - User ID to receive the notification\n * @param {object} notification - Notification data (title, body, etc.)\n * @returns {Promise<string|null>} - ID of the created notification or null if failed\n */\nexport const sendNotification = async (userId, notification) => {\n  if (!userId) {\n    console.error('Invalid user ID for notification');\n    return null;\n  }\n  try {\n    const notificationData = {\n      ...notification,\n      createdAt: new Date().toISOString(),\n      read: false\n    };\n\n    // First check if user exists\n    const userDoc = await getDocs(query(collection(db, 'users'), where('uid', '==', userId)));\n    if (userDoc.empty) {\n      console.error('User not found for notification:', userId);\n      return null;\n    }\n\n    // Add notification to user's subcollection\n    const docRef = await addDoc(collection(db, 'users', userId, 'notifications'), notificationData);\n    return docRef.id;\n  } catch (error) {\n    console.error('Error sending notification:', error);\n    return null;\n  }\n};\n\n/**\n * Listen for notifications for the current user\n * @param {string} userId - User ID to listen for notifications \n * @param {function} onNewNotification - Callback when new notifications arrive\n * @returns {function} - Unsubscribe function\n */\nexport const listenForNotifications = (userId, onNewNotification) => {\n  if (!userId) return () => {};\n  try {\n    const q = query(collection(db, 'users', userId, 'notifications'), orderBy('createdAt', 'desc'));\n    return onSnapshot(q, snapshot => {\n      const notifications = [];\n      let unreadCount = 0;\n      snapshot.forEach(doc => {\n        const data = doc.data();\n        notifications.push({\n          id: doc.id,\n          ...data\n        });\n        if (!data.read) {\n          unreadCount++;\n        }\n      });\n      onNewNotification(notifications, unreadCount);\n    }, error => {\n      console.error('Error listening for notifications:', error);\n    });\n  } catch (error) {\n    console.error('Error setting up notification listener:', error);\n    return () => {}; // Return empty unsubscribe function\n  }\n};\n\n/**\n * Mark a notification as read\n * @param {string} userId - User ID\n * @param {string} notificationId - Notification ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAsRead = async (userId, notificationId) => {\n  if (!userId || !notificationId) return false;\n  try {\n    await updateDoc(doc(db, 'users', userId, 'notifications', notificationId), {\n      read: true,\n      readAt: new Date().toISOString()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error marking notification as read:', error);\n    return false;\n  }\n};\n\n/**\n * Mark all notifications as read\n * @param {string} userId - User ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAllAsRead = async userId => {\n  if (!userId) return false;\n  try {\n    const q = query(collection(db, 'users', userId, 'notifications'), where('read', '==', false));\n    const snapshot = await getDocs(q);\n    if (snapshot.empty) return true;\n    const promises = snapshot.docs.map(doc => updateDoc(doc.ref, {\n      read: true,\n      readAt: new Date().toISOString()\n    }));\n    await Promise.all(promises);\n    return true;\n  } catch (error) {\n    console.error('Error marking all notifications as read:', error);\n    return false;\n  }\n};","map":{"version":3,"names":["collection","addDoc","query","where","orderBy","onSnapshot","getDocs","updateDoc","doc","db","toast","sendNotification","userId","notification","console","error","notificationData","createdAt","Date","toISOString","read","userDoc","empty","docRef","id","listenForNotifications","onNewNotification","q","snapshot","notifications","unreadCount","forEach","data","push","markAsRead","notificationId","readAt","markAllAsRead","promises","docs","map","ref","Promise","all"],"sources":["/Users/yeduruabhiram/Desktop/chiru babai/src/utils/notifications.js"],"sourcesContent":["import { collection, addDoc, query, where, orderBy, onSnapshot, getDocs, updateDoc, doc } from 'firebase/firestore';\nimport { db } from '../firebase/config';\nimport { toast } from 'react-toastify';\n\n/**\n * Send an in-app notification to a specific user\n * @param {string} userId - User ID to receive the notification\n * @param {object} notification - Notification data (title, body, etc.)\n * @returns {Promise<string|null>} - ID of the created notification or null if failed\n */\nexport const sendNotification = async (userId, notification) => {\n  if (!userId) {\n    console.error('Invalid user ID for notification');\n    return null;\n  }\n  \n  try {\n    const notificationData = {\n      ...notification,\n      createdAt: new Date().toISOString(),\n      read: false\n    };\n    \n    // First check if user exists\n    const userDoc = await getDocs(query(collection(db, 'users'), where('uid', '==', userId)));\n    if (userDoc.empty) {\n      console.error('User not found for notification:', userId);\n      return null;\n    }\n    \n    // Add notification to user's subcollection\n    const docRef = await addDoc(collection(db, 'users', userId, 'notifications'), notificationData);\n    return docRef.id;\n  } catch (error) {\n    console.error('Error sending notification:', error);\n    return null;\n  }\n};\n\n/**\n * Listen for notifications for the current user\n * @param {string} userId - User ID to listen for notifications \n * @param {function} onNewNotification - Callback when new notifications arrive\n * @returns {function} - Unsubscribe function\n */\nexport const listenForNotifications = (userId, onNewNotification) => {\n  if (!userId) return () => {};\n  \n  try {\n    const q = query(\n      collection(db, 'users', userId, 'notifications'),\n      orderBy('createdAt', 'desc')\n    );\n    \n    return onSnapshot(q, (snapshot) => {\n      const notifications = [];\n      let unreadCount = 0;\n      \n      snapshot.forEach(doc => {\n        const data = doc.data();\n        notifications.push({\n          id: doc.id,\n          ...data\n        });\n        \n        if (!data.read) {\n          unreadCount++;\n        }\n      });\n      \n      onNewNotification(notifications, unreadCount);\n    }, error => {\n      console.error('Error listening for notifications:', error);\n    });\n  } catch (error) {\n    console.error('Error setting up notification listener:', error);\n    return () => {}; // Return empty unsubscribe function\n  }\n};\n\n/**\n * Mark a notification as read\n * @param {string} userId - User ID\n * @param {string} notificationId - Notification ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAsRead = async (userId, notificationId) => {\n  if (!userId || !notificationId) return false;\n  \n  try {\n    await updateDoc(doc(db, 'users', userId, 'notifications', notificationId), {\n      read: true,\n      readAt: new Date().toISOString()\n    });\n    return true;\n  } catch (error) {\n    console.error('Error marking notification as read:', error);\n    return false;\n  }\n};\n\n/**\n * Mark all notifications as read\n * @param {string} userId - User ID\n * @returns {Promise<boolean>} - Success status\n */\nexport const markAllAsRead = async (userId) => {\n  if (!userId) return false;\n  \n  try {\n    const q = query(\n      collection(db, 'users', userId, 'notifications'),\n      where('read', '==', false)\n    );\n    \n    const snapshot = await getDocs(q);\n    \n    if (snapshot.empty) return true;\n    \n    const promises = snapshot.docs.map(doc => \n      updateDoc(doc.ref, {\n        read: true,\n        readAt: new Date().toISOString()\n      })\n    );\n    \n    await Promise.all(promises);\n    return true;\n  } catch (error) {\n    console.error('Error marking all notifications as read:', error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}